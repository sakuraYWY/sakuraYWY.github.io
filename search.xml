<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>英语语法</title>
      <link href="/2022/07/08/xiao-sheng-chu-ying-yu/"/>
      <url>/2022/07/08/xiao-sheng-chu-ying-yu/</url>
      
        <content type="html"><![CDATA[<h1 id="一-五种基本句型"><a href="#一-五种基本句型" class="headerlink" title="一. 五种基本句型"></a>一. 五种基本句型</h1><p>归根结底，英文句子有其内在的规律:一个英语句子，不论长或短、简单或复杂，无外乎都是由八种成分所组成的，它们分别是主语、谓语、表语、宾语、宾语补足语(简称宾补) 、定语、状语和同位语。</p><p>对于前面五种成分，我们更习惯将其称之为句子的主干成分，它们是构成一个完整的句子所必须的;<br>对于后面三种成分，我们更习惯将其称之为句子的枝干成分，它们只起修饰的作用，即使去掉，也不会影响句子结构的完整性。</p><p>基于五种主干成分，英语句子通常可以划分为五种不同的类型，也就是我们所说的简单句的五种基本句型。关于五种句型的基本结构，我们先来仔细阅读下面这个完美的[LoveStory]，这个爱情故事没有狗血的剧情，只有五个简短的句子，每一个句子代表一种简单句的基本句型:</p><blockquote><ol><li>Nick met Elsa.尼克邂逅了艾尔莎。</li><li>They dated.他们约会了。</li><li>Nick bought EIsa a ring.尼克送给艾尔莎一枚戒指。</li><li>His proposal made Elsa happy.他的求婚令艾尔莎喜出望外。</li><li>They were a perfect match.他们是完美的一对。</li></ol></blockquote><p>现在我们来简单地分析一下上面的这些句子，以句子中的动词为分界线，我们可以把这些句子分割成两部分，即主语部分和谓语部分，见下表:</p><table><thead><tr><th>主语部分</th><th>谓语部分</th></tr></thead><tbody><tr><td>Nick</td><td><strong>met</strong> Elsa</td></tr><tr><td>They</td><td><strong>dated</strong></td></tr><tr><td>Nick</td><td><strong>bought</strong> EIsa a ring</td></tr><tr><td>His proposal</td><td><strong>made</strong> Elsa happy</td></tr><tr><td>They</td><td><strong>were</strong> a perfect match</td></tr></tbody></table><p>从以上的表格我们发现:<br></font><font color=#008000>1. 主语部分通常由名词、代词或者名词短语构成，来表明我们要陈述的对象，即为<strong>主语</strong>。<br>2. 主语后面则为动词，如: met, dated,bought, made, were (均为动词过去式) ，来说明主语做什么，或者是描述主语的状况，即为<strong>谓语部分</strong>。</font></p><p>紧接着，我们将谓语部分进行进一步的细分：</p><table><thead><tr><th>主语</th><th>谓语动词</th><th>其他成分</th><th>五种句型</th></tr></thead><tbody><tr><td>Nick</td><td>met(及物动词)</td><td>Elsa.（宾语）</td><td>①主语+谓语+宾</td></tr><tr><td>They</td><td>date.(不及物动词)</td><td></td><td>②主语+谓语</td></tr><tr><td>Nick</td><td>bought（双宾语动词）</td><td>Elsa (间接宾语) a ring.（直接宾语）</td><td>③主语+谓语+间接宾</td></tr><tr><td>His proposal</td><td>made（宾补动词）</td><td>Elsa (宾语)     happy.（宾语补足语）</td><td>④主语+谓语+宾语+宾语补足语</td></tr><tr><td>They</td><td>were（系动词）</td><td>a perfect match.（表语）</td><td>⑤主语+谓语+表语</td></tr></tbody></table><p>通过以上表格的分析，我们可以看到英文中五种基本句型，它们之所以有的可以接宾语，有的可以接双宾或者是宾语补足语，关键是在于谓语动词。因此，我们可以说，动词构成一个句子的骨架结构。接下来，我们将对每一种句型进行详细的讲解，大家需要注意每一种句型谓语动词的特点。</p><h3 id="①主语-谓语-宾语-S-V-O"><a href="#①主语-谓语-宾语-S-V-O" class="headerlink" title="①主语+谓语+宾语(S+V+O)"></a>①主语+谓语+宾语(S+V+O)</h3><p></font><font color=Blue> 例句①</font></p><blockquote><p>Nick met Elsa.尼克邂逅了艾尔莎</p></blockquote><p>句子的动词为met，表示“遇见”，发出这个动作的人是句首的Nick，它是动词动作的陈述对象，在语法上我们把它称为<strong>主语</strong>。而名词Elsa则为动作met的作用对象，在语法上我们把它称为<strong>宾语</strong>。所以这是一个典型的<strong>主谓宾结构</strong>。句子的意思完整。<br>此句型的谓语动词是<strong>及物动词(transitiveverb)，</strong>在英文中 我们学习的绝大部分动词都为及物动词，在词典中标注为vt.。这种动词往往会告诉我们主语所发出的动作的作用对象是什么，这里作用的对象即为宾语，所以及物动词后面往往是带宾语的。</p><h3 id="②主语-谓语-S-V"><a href="#②主语-谓语-S-V" class="headerlink" title="②主语+谓语(S+V)"></a>②主语+谓语(S+V)</h3><p></font><font color=Blue> 例句②</font></p><blockquote><p>They dated.他们约会了。</p></blockquote><p>句子的动词为date，表示“约会”，发出这个动作的是主语they。所以这是一个典型的<strong>主谓结构</strong>。这里的动词date是一个不 及物动词，也就是说，约会这个动作是主语’they”他们自主完成的，并没有任何作用的对象。你想想他们两个人约会还来个第三者的话，你们觉得这样合适吗?肯定不合适对吧。此句型的谓语动词是<strong>不及物动词(intransitive verb)，</strong>在词典中标注为vi.因为不及物动词所表示的动作没有作用对象，其本身意思完整，故其后不接宾语。</p><h3 id="③主语-谓语-间接宾语-直接宾语-S-V-O-O"><a href="#③主语-谓语-间接宾语-直接宾语-S-V-O-O" class="headerlink" title="③主语+谓语+间接宾语+直接宾语(S+V+O+O)"></a>③主语+谓语+间接宾语+直接宾语(S+V+O+O)</h3><p></font><font color=Blue> 例句③</font></p><blockquote><p>Nick bought EIsa a ring.尼克送给艾尔莎一枚戒指。</p></blockquote><p>动词为bought,表示“买”的意思， 发出“买”这个动作的是句子的主语Nick,并且动词后面接了两个名词，EIsa和ring。我们“买”肯定是买戒指，所以名词ring才是动作作用的对象，是动作的承受者，在语法上我们称为<strong>直接宾语</strong>; “买戒指送给Elsa”,所以Elsa则为动作的接受者，在语法上我们称为<strong>间接宾语</strong>。一个动词后面接两个宾语，这就是一个典型的<strong>主谓双宾</strong>的句型。此句型的谓语动词是<strong>双宾动词(dative&#x2F;erb)，</strong> 顾名思义,这种动词后面通常需要接双宾语，即后面所接的成分即有[人]也有[物]。一般而言，这里的[人]通常指动作的接受者，称作间接宾语。[物] 通常指动作作用的对象，是动作的承受者，称作直接宾语。</p><h3 id="④主语-谓语-宾语-宾语补足语-S-V-O-C"><a href="#④主语-谓语-宾语-宾语补足语-S-V-O-C" class="headerlink" title="④主语+谓语+宾语+宾语补足语(S+V+O+C)"></a>④主语+谓语+宾语+宾语补足语(S+V+O+C)</h3><p></font><font color=Blue>例句④</font></p><blockquote><p>His proposal made Elsa happy.他的求婚令艾尔莎喜出望外。</p></blockquote><p>句子的谓语动词为made,动词后面接了名词EIsa和形容词happy。如果我们只说”hisproposal made EIsa”, 就表示“他的求婚使得艾尔莎”，很显然这个句子的意思是不完整的。于是，我们在Elsa后面接了一个形容词happy,来对宾语EIsa作进一步的补充说明。那在语法.上我们把这个形容词叫做<strong>宾语补足语</strong>，所以这是一个典型的<strong>主谓宾宾语补足语</strong>的句型。此句型的谓语动词是<strong>宾补动词(factitiveverb)，</strong>这种动词后面需要接宾语，并且宾语后面还需要接能补充说明宾语的补足语，使其意思完整。那<strong>宾语+宾语补足语</strong>这种结构我们又称为<strong>复合宾语</strong>。大家注意区分基本句型③中的双宾语和基本句型④中的复合宾语。其实，区分这两种宾语结构的方法很简单，就是在宾语的后面加上一个be动词，若能够构成-一个语义通顺的句子，则为宾语补足语。比如，在句型③的例句中，在宾语的后面加上一个be动词就变成了[EIsa isring]，语义不通顺，故为双宾语结构;在句型④的例句中则变为[EIsis happy]， 其语义通顺，故为复合宾语结构。</p><h3 id="⑤主语-谓语-表语-S-V-P"><a href="#⑤主语-谓语-表语-S-V-P" class="headerlink" title="⑤主语+谓语+表语(S+V+P)"></a>⑤主语+谓语+表语(S+V+P)</h3><p></font><font color=Blue>例句⑤</font></p><blockquote><p>They were a perfect match.他们是完美的一对。</p></blockquote><p>这里的动词为were,属于be动词，they 为句子的主语，也就是说“他们是怎么样的”。后面接了一个名词短语”a perfect match”来补充主语的特征，使句意完整。此句型的谓语动词是系动词(包 括be动词和其他系动词)， 又称为<strong>联系动词(linkingverb)，</strong> 顾名思义，这种动作只起连接的作用，而其本身并不表示具体的动作。故系动词后面所接的成分往往是用来说明主语的特点或者性质，我们将其称为<strong>主语补足语</strong>，或者是<strong>表语</strong>。</p><p>至此，我们就把简单句的五大基本句型弄清楚了，需要注意的是五大句型结构的不同完全是由谓语动词决定的。英文中各种其他复杂的句子均是由这五大句型通过并列、扩充、省略以及倒装等形式变化而来的，所以说五大句型是我们构造和解读英语句子的基础和关键。</p><p></font><font color=#008000>学完这一课你应该回答出以下问题</font> 🧚🧚</p><blockquote><ol><li>英语的五种基本句型是什么？</li><li>每种句型有什么特点？请分别用每一种句型造句，用中文也可以。</li></ol></blockquote><h1 id="二-简单句基本句型（进阶）"><a href="#二-简单句基本句型（进阶）" class="headerlink" title="二. 简单句基本句型（进阶）"></a>二. 简单句基本句型（进阶）</h1><p>我们实际看到的很多句子，往往都是在简单句的基础之上,借助定语或者状语等枝干成分对某些主干成分再作进一步的修饰。首先，我们从简单的单词和词组来看，关于以上所提及到的八种成分可以分别有哪些词性的词来充当呢?因为所涉及的句子成分和词性比较的多，这里我们给大家总结了一张表格，我们一起来仔细看看这个表格，表格所反映的正是词性与句子成分之间的关系。</p><table><thead><tr><th>词性&#x2F;句子成分</th><th>主语</th><th>谓语</th><th>表语</th><th>宾语</th><th>宾补</th><th>定语</th><th>状语</th><th>同位语</th></tr></thead><tbody><tr><td>名词&#x2F;代词</td><td>√</td><td></td><td>√</td><td>√</td><td>√</td><td>√</td><td></td><td>√</td></tr><tr><td>动词</td><td></td><td>√</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>形容词</td><td></td><td></td><td>√</td><td></td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>副词</td><td></td><td></td><td></td><td></td><td></td><td></td><td>√</td><td></td></tr><tr><td>介词短语</td><td></td><td></td><td>√</td><td></td><td>√</td><td>√</td><td>√</td><td></td></tr></tbody></table><ul><li></font><font color=#008000>从表格的纵列来看，我们不难发现:谓语只能由动词来充当;主语、宾语和同位语一般由名词和代词来充当;状语可以由副词和介词短语来充当;表语、宾补和定语多由除动词和副词之外的其它四种词性充当。</li><li>从表格的横列来看，我们不难发现: 除了动词和副词能充当的成分比较单一之外，其它四种词性均可以在句中充当多种成分。</font></li></ul><p>好,我们弄明白了什么样的词性可以充当什么样的句子成分之后呢，现在，我们来将之前，所讲解的五大基本句型作进一步的扩 充，看看简单句是如何通过借助定语、状语和同位语这些枝干分来作进一步修饰的。 大家请先仔细阅读下面这个进阶版的【Seven-sentence Love Story】。</p><blockquote><p>①A handsome boy Nick met a beautifulgirl Elsa.②They dated frequently not long after that.③Suddenly one day, Nick bought EIsa an engagement ring.<br>④His proposal made EIsa extremely happy. ⑤She thought herself the happiestwoman.⑥Not surprisingly, this couple finally got married.⑦In many people’s<br>eyes, they were a perfect match for each other.</p></blockquote><p></font><font color=Blue>例句①</font><br>A handsome boy Nick met a beautiful girl Elsa.<br>帅气的男孩尼克邂逅了漂亮的女孩艾尔莎。</p><ul><li>主谓宾: A boy met a girl.</li><li>handsome &#x2F;beautiful为形容词作定语修饰名词boy&#x2F; girl</li><li>Nick&#x2F;EIsa为名词作同位语补充说明名词boy&#x2F; girl</li></ul><p></font><font color=Blue>例句②</font><br>They dated frequently not long after that.<br>不久以后他们开始频繁地约会。</p><ul><li>主谓: They dated.</li><li>frequently为副词修饰前面的动词date</li><li>not long after that为表示时间的副词短语</li></ul><p></font><font color=Blue>例句③</font><br>Nick bought EIsa an engagement ring.<br>尼克给艾尔莎买了一一个订婚戒指。</p><ul><li>主谓间宾直宾: Nick bought EIsa a ring.</li><li>engagement为名词作定语修饰名词ring</li></ul><p></font><font color=Blue>例句④</font><br>His proposal made EIsa extremely happy.<br>他的求婚令艾尔莎喜出望外。</p><ul><li>主谓宾宾补: His proposal made EIsa happy.</li><li>happy形容词作宾语补足语</li><li>extremely为副词修饰其后面的形容词happy</li></ul><p></font><font color=Blue>例句⑤</font><br>She thought herself the happiest woman.<br>她认为自己是最幸福的女人。</p><ul><li>主谓宾宾补: She thought herself a woman.</li><li>woman名词作宾语补足语</li><li>thehappiest形容词的最高级修饰其后面的名词woman</li></ul><p></font><font color=Blue>例句⑥</font><br>this couple finally got married.<br>这对恋人终于结婚了。</p><ul><li>主系表: this couple got married.</li><li>married形容词作表语</li><li>finally为 副词修饰动词got</li></ul><p></font><font color=Blue>例句⑦</font><br>they were a perfect match for each other.<br>他们真是天造地设的一对。</p><ul><li>主系表: they were a perfect match.</li><li>A perfect match名词短语作表语</li></ul><p>我们可以看出:通过单词或者短语来充当一定的句子成分，只能表达相对简单一点的意思;要想表达稍微复杂一点的意思时，我们就必须依靠一些其它结构来实现。 这里提到的其它结构主要有两大类:一类是非谓语动词，具体包括动词不定式、动名词和分词;另一类则是从句，具体包括名词性从句、定语从句和状语从句。</p><p>那这六种结构又可以分别充当哪些句子成分呢?大家请看下面这张表格:</p><table><thead><tr><th>词性&#x2F;句子成分</th><th>主语</th><th>表语</th><th>宾语</th><th>宾补</th><th>定语</th><th>状语</th><th>同位语</th></tr></thead><tbody><tr><td>动词不定式</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>动名词</td><td>√</td><td>√</td><td>√</td><td></td><td>√</td><td></td><td></td></tr><tr><td>分词</td><td></td><td>√</td><td></td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>状语从句</td><td></td><td></td><td></td><td></td><td></td><td>√</td><td></td></tr><tr><td>定语从句</td><td></td><td></td><td></td><td></td><td>√</td><td></td><td></td></tr><tr><td>名词性从句</td><td>√</td><td>√</td><td>√</td><td></td><td></td><td></td><td>√</td></tr></tbody></table><p>从表格的横列来看，我们不难发现:<br></font><font color=#008000> 1. 非谓语动词的三种形式，也就是动词不定式、动名词和分词，可以在句中充当多种不同的成分，用法十分灵活。<br>2. 名词性从句，顾名思义是指在句中起名词作用的句子。前面刚讲过，名词可以在句中充当主语、表语、宾语和同位语这四种成分，故而名词性从句也有主语从句、表语从句、宾语从句以及同位语从句之分。<br>3. 至于定语从句和状语从句，由于它们各自具有形容词和副词的性质，因此在句中只能分别充当定语和状语，这很容易理解。</font></p><p>因为关于非谓语动词和从句的内容比较多，之后具体的语法章节会给大家详细讲解，大家敬请期待。</p><p></font><font color=#008000>这一节课你应该……</font>🧚🧚</p><blockquote><p>我们在了解了简单句基本句型的基础之上，通过给简单句增加不同的修饰成分，包括单词、短语、非谓语动词以及从句，将简单句扩充为长句子。因此，无论是在之后的英语阅读还是写作中，我们既要学会如何快速拆分一个长句子的主干和修饰成分，也要学会如何正确地写出一个复杂的长句子。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 专属小屁孩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java的垃圾收集机制</title>
      <link href="/2022/07/07/java-de-la-ji-shou-ji-ji-zhi/"/>
      <url>/2022/07/07/java-de-la-ji-shou-ji-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h4 id="1-什么是垃圾收集机制？"><a href="#1-什么是垃圾收集机制？" class="headerlink" title="1. 什么是垃圾收集机制？"></a>1. 什么是垃圾收集机制？</h4><p>垃圾收集器是一种Java 内部机制，负责释放内存，即从内存中删除不必要的对象。它在System类中，即System.gc()。</p><h4 id="2-什么时候回收？"><a href="#2-什么时候回收？" class="headerlink" title="2. 什么时候回收？"></a>2. 什么时候回收？</h4><p>当一个对象的引用不存在时原本分配给这个对象的这块空间就应该被回收。分两种情况：<br>第一种，将对象的引用设置为null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    Cat(String s)&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Cat cat=<span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;小花猫&quot;</span>);</span><br><span class="line">        cat=<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种，一个类声明了两个对象a1和a2，再将a1的引用赋给a2,即a2&#x3D;a1,那么这两个对象就具有相同的引用，即占据同一块a1的内存，那么原本分配给a2的内存就应该被回收了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    Cat(String s)&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Cat cat1=<span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;橘猫&quot;</span>);</span><br><span class="line">        Cat cat2=<span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;中华田园猫&quot;</span>);</span><br><span class="line">        cat1=cat2;</span><br><span class="line">        System.out.println(cat1.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-垃圾收集器的特点？"><a href="#3-垃圾收集器的特点？" class="headerlink" title="3. 垃圾收集器的特点？"></a>3. 垃圾收集器的特点？</h4><p>在后台“移动”程序，类似扫地机，在程序运行时多次启动，因此不必显式调用它并给它命令。在垃圾收集器到达需要回收的对象时，就让对象调用finalize()方法。（finalize()方法来自于Object类，而这个类是所有类的祖先类，所以每个对象都有这个方法。就像equals(),  hashCode()和 toString()）但是它并不总是在对象被销毁之前被调用，举个例子：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Cat</span> &#123;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">int</span> num=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000000</span>;i++)&#123;</span><br><span class="line">            Cat cat=<span class="keyword">new</span> Cat();</span><br><span class="line">            cat=<span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;垃圾收集机制发挥作用的次数为： &quot;</span>+num);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span>()throws Throwable</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;这个猫对象被摧毁啦！&quot;</span>);</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看它的结果<br><img src="/assets/laji.jpg" alt="结果"><br>代码已经覆盖了finalize方法，就是说，每执行一次，会打印出一句“这个猫对象被摧毁啦！”，并且num+1,理论上num应等于1000000才对，但实际上num&#x3D;187462,这意味着垃圾收集机制只执行了187462次。事实告诉我们这个东西并不可靠。</p><h4 id="4-怎么做？"><a href="#4-怎么做？" class="headerlink" title="4.怎么做？"></a>4.怎么做？</h4><p>不要依赖 finalize()释放关键资源的方法。 JVM 可能会调用它，也可能不会。垃圾回收器仅仅能做的是尽可能保证可用内存的使用效率，让可用内存得到高效的管理。程序员可以影响垃圾回收的执行，但不能控制。但当对象在其处于活动状态时拥有一些性能关键资源（例如，打开的数据库连接），则最好创建并显式调用特殊方法以在不再需要该对象时释放它们，以免造成内存泄漏。</p><ol><li>将无用对象设置为null；</li><li>System.gc();<br>虽然可以通过System.gc()来强制回收垃圾，但是这个命令下达后无法保证JVM会立即响应执行，但经验表明，下达命令后，会在短期内执行你的请求。</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>怎样清除讨厌的手机模拟大师？</title>
      <link href="/2022/07/07/zen-yang-qing-chu-tao-yan-de-shou-ji-mo-ni-da-shi/"/>
      <url>/2022/07/07/zen-yang-qing-chu-tao-yan-de-shou-ji-mo-ni-da-shi/</url>
      
        <content type="html"><![CDATA[<p>  手机模拟大师是鲁大师推出的在电脑上运行手机应用的软件，听起来很不错是吧？呵呵，这东西一旦下载了，就很难卸载掉，因为它会隐藏。你手机模拟大师打开文件所在位置，准备卸载它的时候，却发现，这玩意不见了！怎么办？别急，下面是卸载的方法。</p><ol><li>电脑右下角找到手机模拟大师运行图标，点击右键，选择“退出”；<br> <img src="/assets/sh1.jpg" alt="1"></li><li>然后点击我的电脑，在C盘中找到MobileEmuMaster文件夹。<br> <img src="/assets/sh2.jpg" alt="2"></li><li>双击进入MobileEmuMaster文件夹，找到“uninst.exe”文件，双击执行。<br> <img src="/assets/sh4.jpg" alt="3"></li><li>点击继续卸载。<br> <img src="/assets/sh5.jpg" alt="4"></li><li>找到右下角的“残忍卸载”，点击。<br> <img src="/assets/sh6.jpg" alt="5"></li><li>点击“我不要了”。<br> <img src="/assets/sh7.jpg" alt="6"></li><li>点击“反馈并卸载”。<br> <img src="/assets/sh8.jpg" alt="7"></li><li>等待进度完成。<br> <img src="/assets/sh9.jpg" alt="8"></li><li>点击“确认”，至此，卸载完成即可。<br> <img src="/assets/sh10.jpg" alt="9"></li></ol><p> 写在最后：对于我这种对游戏根本不care的人来说，是不可能下载这种东西的，至于它怎么跑到我电脑上的，说出来就很离谱。本来准备下载一个暴风影视5准备和舍友看马嘉祺，（额，舍友的目的是看马嘉祺，我的目的是看看我的电脑能不能放DVD😅）。然后吧，马嘉祺没看成，下载暴风影视顺便还送我了块牛皮糖👿。看着我的C盘的内存0.1G,0.1G的消失，我内心那个焦急啊！烦死了，以后再也不敢乱下东西了，然后疯狂百度……直到最后找到了这个卸载的方法。卸载完以后，整个世界瞬间就清净了。😄</p>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 流氓软件 </tag>
            
            <tag> 心情日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求1~100素数方法</title>
      <link href="/2022/07/04/qiu-su-shu-fang-fa/"/>
      <url>/2022/07/04/qiu-su-shu-fang-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="1-试除法（直接上埃氏筛法，就是有根号那个）"><a href="#1-试除法（直接上埃氏筛法，就是有根号那个）" class="headerlink" title="1. 试除法（直接上埃氏筛法，就是有根号那个）"></a>1. 试除法（直接上埃氏筛法，就是有根号那个）</h2><p>一个数设为a，若它是合数，则a的公因数其中一个大于√a，那么另外一个就小于√a，要么就两个都等于√a；而素数只有它本身和1两个因数。在用试除法判断a是否为素数时，只用把a模上从2到√a，若结果出现0，直接跳出这个数的判断循环，紧接着下一个；若模到√a结果都不是0的话，a就是素数，这个时候被模的数就大于√a，根据这个标志就可以得到素数啦！（废话不多，上代码）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Prime</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>( j=<span class="number">2</span>;j&lt;Math.sqrt(i);j++)&#123;<span class="comment">//Math.sqrt(i)也可以改成i/2,下面也要一起改</span></span><br><span class="line">          <span class="keyword">if</span>(i%j==<span class="number">0</span>)&#123;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(j&gt;Math.sqrt(i))</span><br><span class="line">          System.out.println(i);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-欧拉筛法"><a href="#2-欧拉筛法" class="headerlink" title="2. 欧拉筛法"></a>2. 欧拉筛法</h2><p>先假设每一个数都是素数，从2开始，看后面的每一个数是不是质数的倍数，若是，则筛去。由于每个数只会被筛一次，所以时间复杂度为O(n)。<br>假设这里有1至100的数字，1不是素数，那就从2开始，筛除（2<em>2，2</em>3，2<em>4……2</em>50(2<em>50)&gt;&#x3D;100），即筛出了除2以外2的倍数；到3，筛除（3</em>3,3<em>4,3</em>5……3<em>33（3</em>34&gt;100)），即筛除了3的倍数；以此类推，因为10*10&gt;&#x3D;100,所以筛到10的倍数就可以了！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">prime</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=<span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> array[]=<span class="keyword">new</span> <span class="title class_">int</span> [n];</span><br><span class="line">        <span class="type">boolean</span> is_prime[]=<span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">           array[i]=i;</span><br><span class="line">           is_prime[i]=<span class="literal">true</span>;</span><br><span class="line">       &#125;<span class="comment">//先初始化数组，假设每一个数都是素数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i*i;j&lt;n;j+=i)&#123;<span class="comment">//j+=相当于j=i*(i+1),j=i*(i+2)……</span></span><br><span class="line">                is_prime[j]=<span class="literal">false</span>;<span class="comment">//筛除质数的倍数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(is_prime[i])&#123;</span><br><span class="line">              System.out.println(array[i]);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown语法</title>
      <link href="/2022/07/03/markdown-yu-fa/"/>
      <url>/2022/07/03/markdown-yu-fa/</url>
      
        <content type="html"><![CDATA[<ol><li><p>在文章中插入图片</p><blockquote><p>![图片名称](图片路径)<br>例如：![photo](&#x2F;assets&#x2F;tupian.jpg)</p></blockquote></li><li><p>添加链接</p><blockquote><p>[链接名称](链接)<br>例如：[百度](<a href="https://baidu.com/">https://baidu.com\</a>)</p></blockquote></li><li><p>添加标题</p><blockquote><p># 一级标题<br>## 二级标题<br>……<br>###### 六级标题<br>（最多有六级标题哦！并且#号和标题之间要有空格）</p></blockquote></li><li><p>有序列表</p><blockquote><p>1.(空格)内容<br>例如1. 内容</p></blockquote></li><li><p>无序列表</p><blockquote><p>-(空格)内容<br>例如：- 内容</p></blockquote></li><li><p>强调</p><blockquote><p>*被强调内容*<br>例如：<em>被强调内容</em></p></blockquote></li><li><p>加粗</p><blockquote><p>**被加粗内容**<br>例如：<strong>被加粗内容</strong></p></blockquote></li><li><p>引用</p><blockquote><p>&gt;引用内容</p></blockquote></li><li><p>添加表情包<br>进入这个网址<a href="https://www.emojidaquan.com/">表情包大全</a>,点击想要的表情包（就相当于复制了），然后在你的文章中相应位置粘贴即可。</p></li></ol><p>更多语法内容，请参照<a href="https://www.runoob.com/markdown/md-tutorial.html">菜鸟教程</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo常用的几个命令</title>
      <link href="/2022/07/03/hexo-chang-yong-de-ji-ge-ming-ling/"/>
      <url>/2022/07/03/hexo-chang-yong-de-ji-ge-ming-ling/</url>
      
        <content type="html"><![CDATA[<p>首先得在博客根目录下Git Bash Here</p><ol><li><blockquote><p>$ hexo s</p></blockquote></li></ol><p>启动本地服务器，可以预览博客效果，Ctrl+C结束</p><ol start="2"><li><blockquote><p>$hexo new “笔记标题”</p></blockquote></li></ol><p>新建一篇标题为“笔记标题”的文章</p><ol start="3"><li><blockquote><p>$hexo d</p></blockquote></li></ol><p>生成网站静态文件，并部署到设定的仓库，这样就相当于把网页公之于众</p><ol start="4"><li><blockquote><p>$ hexo clean</p></blockquote></li></ol><p>清楚缓存文件db.json和已生成的静态文件（网站显示异常时可以执行这条命令试试）</p><ol start="5"><li><blockquote><p>$hexo g</p></blockquote></li></ol><p>生成网站静态文件到默认设置的public文件夹。</p><ul><li>便于查看网站生成的静态文件或者手动部署网站；</li><li>如果使用自动部署，不需要先执行该命令；</li><li>hexo g 是 hexo generate 的缩写，命令效果一致。</li></ul><ol start="6"><li><blockquote><p>$hexo new page 标题</p></blockquote></li></ol><p>新建一个标题为“标题”的页面，默认链接地址为 主页地址&#x2F;标题&#x2F;</p><ul><li>标题可以为中文，但一般习惯用英文；</li><li>页面标题和文章一样可以随意修改；</li><li>页面不会出现在首页文章列表和归档中，也不支持设置分类和标签。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 博客入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随便聊一聊</title>
      <link href="/2022/07/03/sui-bian-liao-yi-liao/"/>
      <url>/2022/07/03/sui-bian-liao-yi-liao/</url>
      
        <content type="html"><![CDATA[<p>这几天有些郁闷，不知道是天气还是什么原因，总是睡不着。有很多想法，也有想实现的冲动，但是又被考试束缚了手脚。听朋友说博客很好用，可以把自己所学的东西放上去，而且还可以与各大网友共享，于是我就搭建了这个博客。由于忙着考试，正如你所看到的那样，这个博客还很简陋，后期我会美化它的！最后感谢你能在百忙之中能读完这篇文章，爱你！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 心情日记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
